#!/usr/bin/env python3

import sys
import logging
import time

sys.path.insert( 1,  '..')

from subcontractor.daemon import Daemon
from subcontractor.contractor import Contractor
from subcontractor.handler import Handler

class Main( Daemon ):
  default_config_file = '/etc/subcontractor.conf'

  def __init__( self, *args,  **kwargs ):
    super().__init__( 'subcontractor', *args, **kwargs )
    self.contractor = None
    self.site = None
    self.cont = True
    self.handler = Handler()

  def config( self, config ):
    host = config.get( 'contractor', 'host' )
    root_path = config.get( 'contractor', 'root_path' )
    port = config.get( 'contractor', 'port' )
    proxy = config.get( 'contractor', 'proxy' )
    self.contractor = Contractor( host=host, root_path=root_path, port=port, proxy=proxy )
    self.site = config.get( 'subcontractor', 'site' )
    self.poll_interval = config.getint( 'subcontractor', 'poll_interval' )
    self.max_job_request_size = config.getint( 'subcontractor', 'max_job_request_size' )
    self.handler.setLimits( job_delay=config.getint( 'subcontractor', 'job_delay' ), max_concurent_jobs=config.getint( 'subcontractor', 'max_concurent_jobs' ) )
    for ( name, limit ) in config.items( 'modules' ):
      try:
        limit = int( limit )
      except ValueError:
        logger.error( 'invalid limit "{0}" for pluting "{1}"'.format( limit, name ) )

      if limit < 1:
        continue

      self.handler.registerModule( name )
      self.handler.setLimits( module=name, max_concurent_jobs=int( limit ) )

  def main( self ):
    logging.debug( 'starting...' )
    while self.cont:
      self.handler.addJobs( self.contractor.getJobs( self.site, self.handler.module_list, min( self.handler.empty_slots, self.max_job_request_size ) ) )
      logging.debug( 'delay' )
      time.sleep( self.poll_interval ) # using time.sleep instead of a event.wait( timeout=? ) to avoid time warping problems, just going to have to wait poll_interval seconds for it to shutdown

    logging.info( 'wiating for jobs to finish' )
    self.handler.wait()
    logging.debug( 'done.' )

  def stop( self ):
    self.cont = False

if __name__ == '__main__':
  Main().run()
